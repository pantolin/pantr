---
alwaysApply: true
---

## 1. Project Scope & Environment
* All code must be written for **Python 3.12**.
* The primary dependencies for this project are **NumPy**, **SciPy**, **Matplotlib**, and **Numba**.
* Do not introduce other major dependencies without confirmation.

## 2. Code Style & Structure
* Follow **PEP 8** style guidelines strictly.
* Use `f-strings` for all string formatting.
* Use `pathlib.Path` for all file system paths instead of `os.path`.
* All `.py` files must include a 2-line (max) module-level docstring at the top, explaining the file's purpose.

## 3. Type Hinting (Strict)
* **Mandatory Type Hints:** All function/method definitions (arguments and return types) and class members must have type hints.
* **NumPy Typing:**
    * Import `numpy.typing` as `npt` (e.g., `from numpy import typing as npt`).
    * Use `npt.NDArray` for all NumPy arrays. Be descriptive and specify the `dtype` (e.g., `arr: npt.NDArray[np.float64]`).
    * Details on dimension, shape, or memory layout (ordering) should be included in the docstring if not obvious.
* **Guarded Typing Imports:**
    * When an import is needed *only* for type hinting and would cause a circular import or slow down runtime, guard it using `typing.TYPE_CHECKING`.
    * Example:
        ```python
        from typing import TYPE_CHECKING

        if TYPE_CHECKING:
            from .some_other_module import HeavyClass
        ```

## 4. Documentation (Google Style)
* All public functions, methods, and classes must have **Google-style docstrings**.
* **Class Documentation:** Every class docstring must include:
    * A one-line summary of the class.
    * A more detailed description of its purpose and behavior.
    * An `Attributes:` section documenting all public class members (variables), including their type and description.
* **Function/Method Documentation:**
    * The `Args:` section must list each argument, its type, and a description.
    * The `Returns:` or `Yields:` section must describe the return value and its type.
    * Any specific exceptions raised should be documented in a `Raises:` section.

## 5. Scientific Computing Libraries
* **NumPy:** Always use vectorized operations. Avoid explicit Python `for` loops over `ndarray` elements.
* **SciPy:** Import and use specific submodules (e.g., `from scipy import optimize`, `from scipy.interpolate import interp1d`).
* **Matplotlib:** Always add clear axis labels (`xlabel`, `ylabel`) and a `title` to all plots.
* **Numba:** If a function involves complex loops or math that cannot be vectorized, suggest applying the **`@numba.jit(nopython=True)`** decorator to accelerate it.

## 6. Testing
* All new logic, functions, and classes should be accompanied by unit tests.
* Tests must be written using the **pytest** framework.
* Use `pytest.raises` to test for expected exceptions.
* When comparing floating-point arrays in tests, use `numpy.testing` functions (e.g., `np.testing.assert_allclose`).

## 7. Error Handling
* Implement robust error handling.
* Use specific exception types (e.g., `ValueError`, `FileNotFoundError`, `TypeError`) instead of generic `Exception`.
* Use `try-except` blocks for I/O operations (e.g., reading files).

## 8. Version Control (Git)
* **Atomic Commits:** Structure your commits to be atomic. Each commit should group all changes (e.g., implementation, tests, documentation) related to a single, logical feature or bugfix. Avoid mixing unrelated changes in one commit.
* **Commit Message Format:** All commit messages must have a subject line and a body.
    * **Subject:** A short, imperative summary of the change (e.g., "Add feature for X", "Fix bug in Y").
    * **Body:** After the subject line (and a blank line), provide a more extended description of *what* was changed and *why* the change was made.